import React, { useState, useEffect } from "react";
import {
  Box, Typography, TextField, Button, Stack,
  Card, Divider, Select, MenuItem, FormControl, InputLabel,
  RadioGroup, Radio, FormControlLabel, LinearProgress, Alert, Tabs, Tab
} from "@mui/material";
import { doc, setDoc, getDoc, getDocs, collection } from "firebase/firestore";
import { db } from "./firebase";
import {
  downloadBackupAsJSON,
  downloadBackupAsExcel
} from "./utils/backupUtils";
import {
  restoreFromJSONFile,
  restoreFromExcelFile
} from "./utils/restoreUtils";
import { deleteAllDateFields as handleDeleteAllUtil } from "./utils/deleteUtils";

import Banner from "./pages/Banner";
import { useNavigate } from "react-router-dom";

// ‚úÖ Th√™m d√≤ng n√†y ƒë·ªÉ s·ª≠a l·ªói icon ch∆∞a ƒë·ªãnh nghƒ©a
import LockResetIcon from "@mui/icons-material/LockReset";

export default function Admin({ onCancel }) {
  const [firestoreEnabled, setFirestoreEnabled] = useState(false);
  const [passwords, setPasswords] = useState({
    yte: "",
    ketoan: "",
    bgh: "",
    admin: ""
  });
  const [selectedAccount, setSelectedAccount] = useState("admin");
  const [newPassword, setNewPassword] = useState("");
  const [backupFormat, setBackupFormat] = useState("json");
  const [restoreProgress, setRestoreProgress] = useState(0);
  const [alertMessage, setAlertMessage] = useState("");
  const [alertSeverity, setAlertSeverity] = useState("success");
  const [deleteInProgress, setDeleteInProgress] = useState(false);
  const [deleteMessage, setDeleteMessage] = useState("");
  const [deleteSeverity, setDeleteSeverity] = useState("info");
  const [deleteProgress, setDeleteProgress] = useState(0);
  const [setDefaultProgress, setSetDefaultProgress] = useState(0);
  const [setDefaultMessage, setSetDefaultMessage] = useState("");
  const [setDefaultSeverity, setSetDefaultSeverity] = useState("success");
  const [tabIndex, setTabIndex] = useState(0);
  const navigate = useNavigate();

  const [selectedYear, setSelectedYear] = useState("2024-2025");

  const yearOptions = [
    "2024-2025",
    "2025-2026",
    "2026-2027",
    "2027-2028",
    "2028-2029"
  ];

  useEffect(() => {
    const fetchSettings = async () => {
      try {
        const accounts = ["admin", "yte", "ketoan", "bgh"];
        const newPasswords = {};
        for (const acc of accounts) {
          const snap = await getDoc(doc(db, "ACCOUNT", acc.toUpperCase()));
          newPasswords[acc] = snap.exists() ? snap.data().password || "" : "";
        }
        setPasswords(newPasswords);

        const toggleSnap = await getDoc(doc(db, "SETTINGS", "TAIDULIEU"));
        if (toggleSnap.exists()) setFirestoreEnabled(toggleSnap.data().theokhoi);
      } catch (error) {
        console.error("‚ùå L·ªói khi t·∫£i c·∫•u h√¨nh:", error);
      }
    };

    const fetchYear = async () => {
      try {
        const yearSnap = await getDoc(doc(db, "YEAR", "NAMHOC"));
        if (yearSnap.exists()) {
          const firestoreYear = yearSnap.data().value;
          if (firestoreYear) {
            setSelectedYear(firestoreYear);
          }
        }
      } catch (error) {
        console.error("‚ùå L·ªói khi l·∫•y nƒÉm h·ªçc t·ª´ Firestore:", error);
      }
    };

    fetchSettings();
    fetchYear();
  }, []);

  useEffect(() => {
    if (restoreProgress === 100) {
      const timer = setTimeout(() => setRestoreProgress(0), 3000);
      return () => clearTimeout(timer);
    }
  }, [restoreProgress]);

  const handleYearChange = async (newYear) => {
    setSelectedYear(newYear);

    try {
      await setDoc(doc(db, "YEAR", "NAMHOC"), {
        value: newYear
      });

      console.log(`‚úÖ ƒê√£ c·∫≠p nh·∫≠t nƒÉm h·ªçc: ${newYear}`);
    } catch (error) {
      console.error("‚ùå L·ªói khi ghi nƒÉm h·ªçc v√†o Firestore:", error);
      alert("Kh√¥ng th·ªÉ c·∫≠p nh·∫≠t nƒÉm h·ªçc!");
    }
  };

  const handleToggleChange = async (e) => {
    const newValue = e.target.value === "khoi";
    setFirestoreEnabled(newValue);
    try {
      await setDoc(doc(db, "SETTINGS", "TAIDULIEU"), { theokhoi: newValue });
    } catch (error) {
      alert("‚ùå Kh√¥ng th·ªÉ c·∫≠p nh·∫≠t ch·∫ø ƒë·ªô Firestore!");
    }
  };

  const handleChangePassword = async (type) => {
    if (!newPassword.trim()) {
      alert("‚ö†Ô∏è Vui l√≤ng nh·∫≠p m·∫≠t kh·∫©u m·ªõi!");
      return;
    }

    
    // Mapping t√™n hi·ªÉn th·ªã cho c√°c t√†i kho·∫£n
    const accountDisplayNames = {
      yte: "Y t·∫ø",
      ketoan: "K·∫ø to√°n",
      bgh: "BGH",
      admin: "Admin"
    };

    try {
      await setDoc(
        doc(db, "ACCOUNT", type.toUpperCase()),
        { password: newPassword },
        { merge: true } // Gi·ªØ l·∫°i c√°c field kh√°c
      );

      setPasswords((prev) => ({
        ...prev,
        [type]: newPassword
      }));

      const displayName = accountDisplayNames[type] || type;
      alert(`‚úÖ ƒê√£ ƒë·ªïi m·∫≠t kh·∫©u cho t√†i kho·∫£n ${displayName}!`);
      setNewPassword("");
    } catch (err) {
      alert("‚ùå Kh√¥ng th·ªÉ ƒë·ªïi m·∫≠t kh·∫©u!");
    }
  };

  const handleCreateAccounts = async () => {
  try {
    const truongRef = doc(db, "DANHSACH_2024-2025", "TRUONG");
    const truongSnap = await getDoc(truongRef);

    if (!truongSnap.exists()) {
      alert("‚ùå Kh√¥ng t√¨m th·∫•y d·ªØ li·ªáu TRUONG!");
      return;
    }

    const list = truongSnap.data().list; // l√† m·∫£ng nh∆∞ ["1.1", "1.2", "2.1"]
      if (!Array.isArray(list)) {
        alert("‚ùå Danh s√°ch l·ªõp kh√¥ng h·ª£p l·ªá!");
        return;
      }

      const created = [];

      for (const lop of list) {
        await setDoc(doc(db, "ACCOUNT", lop), {
          password: "123456" // ho·∫∑c sinh m·∫≠t kh·∫©u ri√™ng cho m·ªói l·ªõp
        });
        created.push(lop);
      }

      alert(`‚úÖ ƒê√£ t·∫°o ${created.length} t√†i kho·∫£n l·ªõp: ${created.join(", ")}`);
    } catch (error) {
      console.error("‚ùå L·ªói khi t·∫°o t√†i kho·∫£n:", error.message);
      alert("‚ùå Kh√¥ng th·ªÉ t·∫°o t√†i kho·∫£n l·ªõp!");
    }
  };


  const handleDeleteAll = async () => {
    const confirmed = window.confirm(`‚ö†Ô∏è B·∫°n c√≥ ch·∫Øc ch·∫Øn mu·ªën x√≥a t·∫•t c·∫£ d·ªØ li·ªáu ƒëi·ªÉm danh c·ªßa nƒÉm ${selectedYear}?`);
    if (!confirmed) return;

    await handleDeleteAllUtil({
      setDeleteInProgress,
      setDeleteProgress,
      setDeleteMessage,
      setDeleteSeverity,
      namHocValue: selectedYear, // ‚úÖ Truy·ªÅn gi√° tr·ªã nƒÉm h·ªçc ƒë·ªông v√†o ƒë√¢y
    });
  };


  const handleSetDefault = async () => {
    const confirmed = window.confirm("‚ö†Ô∏è B·∫°n c√≥ ch·∫Øc mu·ªën reset ƒëi·ªÉm danh?");
    if (!confirmed) return;

    try {
      setSetDefaultProgress(0);
      setSetDefaultMessage("");
      setSetDefaultSeverity("info");

      // üîç L·∫•y nƒÉm h·ªçc hi·ªán t·∫°i t·ª´ YEAR/NAMHOC
      const namHocDoc = await getDoc(doc(db, "YEAR", "NAMHOC"));
      const namHocValue = namHocDoc.exists() ? namHocDoc.data().value : null;
      if (!namHocValue) {
        setSetDefaultMessage("‚ùå Kh√¥ng t√¨m th·∫•y nƒÉm h·ªçc h·ª£p l·ªá trong h·ªá th·ªëng!");
        setSetDefaultSeverity("error");
        return;
      }

      const collectionName = `BANTRU_${namHocValue}`;
      const snapshot = await getDocs(collection(db, collectionName));
      const docs = snapshot.docs;
      const total = docs.length;
      let completed = 0;

      for (const docSnap of docs) {
        const data = docSnap.data();
        let newData = {
          ...data,
          vang: "",
          lyDo: ""
        };
        if (data.huyDangKy !== "x") {
          newData.huyDangKy = "T";
        }
        await setDoc(doc(db, collectionName, docSnap.id), newData);
        completed++;
        setSetDefaultProgress(Math.round((completed / total) * 100));
      }

      setSetDefaultMessage("‚úÖ ƒê√£ reset ƒëi·ªÉm danh!");
      setSetDefaultSeverity("success");
    } catch (error) {
      setSetDefaultMessage("‚ùå L·ªói khi c·∫≠p nh·∫≠t huyDangKy.");
      setSetDefaultSeverity("error");
    } finally {
      setTimeout(() => setSetDefaultProgress(0), 3000);
    }
  };

  const handleInitNewYearData = async () => {
    const confirmed = window.confirm(`‚ö†Ô∏è B·∫°n c√≥ ch·∫Øc mu·ªën kh·ªüi t·∫°o d·ªØ li·ªáu cho nƒÉm ${selectedYear}?`);
    if (!confirmed) return;

    const danhSachDocs = ["K1", "K2", "K3", "K4", "K5", "TRUONG"];

    try {
      // ‚úÖ Kh·ªüi t·∫°o c√°c t√†i li·ªáu b√™n trong DANHSACH
      for (const docName of danhSachDocs) {
        await setDoc(doc(db, `DANHSACH_${selectedYear}`, docName), {
          list:""
        });
      }

      // ‚úÖ Kh·ªüi t·∫°o t√†i li·ªáu init trong BANTRU (kh√¥ng d√πng "__init__")
      await setDoc(doc(db, `BANTRU_${selectedYear}`, "init"), {
        temp: ""
      });

      alert(`‚úÖ ƒê√£ kh·ªüi t·∫°o d·ªØ li·ªáu cho nƒÉm h·ªçc ${selectedYear}`);
    } catch (err) {
      console.error("‚ùå L·ªói khi kh·ªüi t·∫°o d·ªØ li·ªáu:", err);
      alert("‚ùå Kh√¥ng th·ªÉ kh·ªüi t·∫°o d·ªØ li·ªáu nƒÉm m·ªõi!");
    }
  };

  return (
    <Box sx={{ minHeight: "100vh", backgroundColor: "#e3f2fd" }}>
      <Banner title="QU·∫¢N TR·ªä H·ªÜ TH·ªêNG" />
      <Box sx={{ width: { xs: "95%", sm: 450 }, mx: "auto", mt: 3 }}>
        <Card elevation={10} sx={{ p: 3, borderRadius: 4 }}>
          <Tabs
            value={tabIndex}
            onChange={(e, newValue) => setTabIndex(newValue)}
            variant="scrollable"
            scrollButtons="auto"
          >
            <Tab label="‚öôÔ∏è System" />
            <Tab label="üóÑÔ∏è Database" />
          </Tabs>

          {tabIndex === 0 && (
            <Stack spacing={3} mt={3} sx={{ maxWidth: 300, mx: "auto", width: "100%" }}>
              <Button variant="contained" onClick={() => navigate("/quanly")} sx={{ maxWidth: 300, width: "100%" }}>
                üè´ H·ªÜ TH·ªêNG QU·∫¢N L√ù B√ÅN TR√ö
              </Button>

              <FormControl fullWidth sx={{ maxWidth: 300 }}>
                <InputLabel id="year-select-label">NƒÉm h·ªçc</InputLabel>
                <Select
                  labelId="year-select-label"
                  label="NƒÉm h·ªçc"
                  value={selectedYear}
                  onChange={(e) => handleYearChange(e.target.value)} // ‚Üê G·ªçi h√†m ghi Firestore
                >
                  {yearOptions.map((year) => (
                    <MenuItem key={year} value={year}>
                      {year}
                    </MenuItem>
                  ))}
                </Select>
              </FormControl>

              <Button
                variant="contained"
                color="info"
                onClick={handleInitNewYearData}
                sx={{
                  maxWidth: 300,
                  width: "100%",
                  backgroundColor: "#0288d1", // xanh d∆∞∆°ng nh·∫°t
                  "&:hover": { backgroundColor: "#01579b" }
                }}
              >
                üÜï Kh·ªüi t·∫°o d·ªØ li·ªáu nƒÉm m·ªõi
              </Button>

              <FormControl fullWidth sx={{ maxWidth: 300 }}>
                <InputLabel id="account-select-label">Lo·∫°i t√†i kho·∫£n</InputLabel>
                <Select
                  labelId="account-select-label"
                  label="Lo·∫°i t√†i kho·∫£n"
                  value={selectedAccount}
                  onChange={(e) => setSelectedAccount(e.target.value)}
                >
                  <MenuItem value="yte">üè• Y t·∫ø</MenuItem>
                  <MenuItem value="ketoan">üí∞ K·∫ø to√°n</MenuItem>
                  <MenuItem value="bgh">üìã BGH</MenuItem>
                  <MenuItem value="admin">üîê Admin</MenuItem>
                </Select>
              </FormControl>

              <TextField
                label="üîë M·∫≠t kh·∫©u m·ªõi"
                type="password"
                value={newPassword}
                onChange={(e) => setNewPassword(e.target.value)}
                fullWidth
                sx={{ maxWidth: 300 }}
              />
              <Button
                variant="contained"
                color="warning"
                onClick={() => handleChangePassword(selectedAccount)}
                sx={{ maxWidth: 300, width: "100%" }}
                startIcon={<LockResetIcon />}
              >
                ƒê·ªïi m·∫≠t kh·∫©u
              </Button>
              
              <Button
                variant="outlined"
                color="secondary"
                onClick={handleCreateAccounts}
                sx={{ maxWidth: 300, width: "100%" }}
              >
                üÜï T·∫°o t√†i kho·∫£n m·∫∑c ƒë·ªãnh
              </Button>

              <FormControl>
                <Typography variant="subtitle1" fontWeight="bold">
                  üìä T·∫£i d·ªØ li·ªáu t·ª´ Firestore
                </Typography>
                <RadioGroup
                  row
                  value={firestoreEnabled ? "khoi" : "lop"}
                  onChange={handleToggleChange}
                >
                  <FormControlLabel value="khoi" control={<Radio />} label="T·∫£i theo kh·ªëi" />
                  <FormControlLabel value="lop" control={<Radio />} label="T·∫£i theo l·ªõp" />
                </RadioGroup>
              </FormControl>
            </Stack>
          )}

          {tabIndex === 1 && (
            <Stack spacing={3} mt={3} sx={{ maxWidth: 300, mx: "auto", width: "100%" }}>
              <Divider>
                <Typography fontWeight="bold">üíæ Sao l∆∞u & Ph·ª•c h·ªìi</Typography>
              </Divider>

              <RadioGroup
                row
                value={backupFormat}
                onChange={(e) => setBackupFormat(e.target.value)}
              >
                <FormControlLabel value="json" control={<Radio />} label="JSON" />
                <FormControlLabel value="excel" control={<Radio />} label="Excel" />
              </RadioGroup>

              <Button
                variant="contained"
                color="success"
                onClick={() => backupFormat === "json" ? downloadBackupAsJSON() : downloadBackupAsExcel()}
                sx={{ maxWidth: 300, width: "100%" }}
              >
                üì• Sao l∆∞u ({backupFormat.toUpperCase()})
              </Button>

              <Button
                variant="contained"
                color="secondary"
                component="label"
                sx={{ maxWidth: 300, width: "100%" }}
              >
                üîÅ Ph·ª•c h·ªìi ({backupFormat.toUpperCase()})
                <input
                  type="file"
                  accept={backupFormat === "json" ? ".json" : ".xlsx"}
                  hidden
                  onChange={(e) => {
                    const file = e.target.files[0];
                    if (!file) return;
                    if (!window.confirm("‚ö†Ô∏è Ph·ª•c h·ªìi s·∫Ω ghi ƒë√® d·ªØ li·ªáu. Ti·∫øp t·ª•c?")) {
                      e.target.value = "";
                      return;
                    }
                    const restore = async () => {
                      if (backupFormat === "json") {
                        await restoreFromJSONFile(file, setRestoreProgress, setAlertMessage, setAlertSeverity);
                      } else {
                        await restoreFromExcelFile(file, setRestoreProgress, setAlertMessage, setAlertSeverity);
                      }
                      e.target.value = "";
                    };
                    restore();
                  }}
                />
              </Button>

              <Divider>
                <Typography fontWeight="bold" color="error">üóëÔ∏è X√≥a & Reset d·ªØ li·ªáu</Typography>
              </Divider>

              <Button
                variant="contained"
                color="error"
                onClick={handleDeleteAll}
                sx={{ maxWidth: 300, width: "100%", backgroundColor: "#d32f2f", "&:hover": { backgroundColor: "#9a0007" } }}
              >
                üóëÔ∏è X√≥a Database Firestore
              </Button>

              <Button
                variant="contained"
                color="primary"
                onClick={handleSetDefault}
                sx={{ maxWidth: 300, width: "100%" }}
              >
                ‚ôªÔ∏è Reset ƒëi·ªÉm danh
              </Button>
              
              {(restoreProgress > 0 || deleteProgress > 0 || setDefaultProgress > 0) && (
                <Box sx={{ mt: 2 }}>
                  <LinearProgress
                    variant="determinate"
                    value={restoreProgress || deleteProgress || setDefaultProgress}
                    sx={{ height: 10, borderRadius: 5 }}
                  />
                  <Typography variant="caption" align="center" display="block" mt={0.5}>
                    {restoreProgress > 0
                      ? `ƒêang ph·ª•c h·ªìi... ${restoreProgress}%`
                      : deleteProgress > 0
                        ? `ƒêang x√≥a... ${deleteProgress}%`
                        : `ƒêang reset... ${setDefaultProgress}%`}
                  </Typography>
                </Box>
              )}

              {alertMessage && <Alert severity={alertSeverity} onClose={() => setAlertMessage("")}>{alertMessage}</Alert>}
              {deleteMessage && <Alert severity={deleteSeverity} onClose={() => setDeleteMessage("")}>{deleteMessage}</Alert>}
              {setDefaultMessage && <Alert severity={setDefaultSeverity} onClose={() => setSetDefaultMessage("")}>{setDefaultMessage}</Alert>}
            </Stack>
          )}
        </Card>
      </Box>
    </Box>
  );
}


